C51 COMPILER V8.08   MIMASUO                                                               08/18/2015 22:08:02 PAGE 1   


C51 COMPILER V8.08, COMPILATION OF MODULE MIMASUO
OBJECT MODULE PLACED IN mimasuo.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE mimasuo.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*********************************************************************************
   2          * 【编写时间】： 2014年3月5日
   3          * 【作    者】： 清翔电子:03
   4          * 【版    本】： 1.0
   5          * 【网    站】： http://www.qxmcu.com/ 
   6          * 【淘宝店铺】： http://qxmcu.taobao.com/ 
   7          * 【实验平台】： QX-MCS51 单片机开发板
   8          * 【外部晶振】： 11.0592mhz     
   9          * 【主控芯片】： STC89C52
  10          * 【编译环境】： Keil μVisio3  
  11          * 【程序功能】：                                                                                    
  12          * 【使用说明】： 
  13          *  说明：免费开源，不提供源代码分析.
  14          **********************************************************************************/
  15          /********************************************************************************
  16                                                                          功能键
  17                                                          S6---S115       数字键0-9
  18                                          S16---更改密码          S17---更改密码完毕后确认
  19                                          S18---重试密码、重新设定        S19---关闭密码锁
  20                                          初始密码：000000        密码位数：6位
  21                                          注意：掉电后，所设密码会丢失，重新上点时，密码恢复为原始的000000
  22                                          与P1相连的8位发光LED点亮代表锁被打开；熄灭代表锁被锁上
  23          
  24          程序功能：
  25                            1、开锁：
  26                            下载程序后，直接按六次S6（即代表数字0），8位LED亮，锁被打开，输入密码时，
  27                            六位数码管依次显示小横杠。
  28                            2、更改密码：
  29                            只有当开锁（LED亮）后，该功能方可使用。
  30                            首先按下更改密码键S16，然后设置相应密码，此时六位数码管会显示设置密码对应
  31                            的数字。最后设置完六位后，按下S17确认密码更改，此后新密码即生效。
  32                            3、重试密码：
  33                            当输入密码时，密码输错后按下键S18，可重新输入六位密码。
  34                            当设置密码时，设置中途想更改密码，也可按下此键重新设置。
  35                            4、关闭密码锁：
  36                            按下S19即可将打开的密码锁关闭。
  37          推荐初级演示步骤：输入原始密码000000按6次S6密码正确后LED全部亮表示锁已打开---按下更
  38          改密码按键S16---按S6到S15设置密码---按S17
  39                                  确认密码更改---按S19关闭密码锁---输入新的密码打开密码锁
  40          *******************************************************************************/
  41          #include<reg52.h>
  42          
  43          #define uchar unsigned char
  44          #define uint unsigned int
  45          
  46          uchar old1,old2,old3,old4,old5,old6; //原始密码000000
  47          uchar new1,new2,new3,new4,new5,new6;  //每次MCU采集到的密码输入
  48          uchar a=16,b=16,c=16,d=16,e=16,f=16; //送入数码管显示的变量
  49          uchar wei,key,temp;
  50          
  51          bit allow,genggai,ok,wanbi,retry,close;  //各个状态位
  52          
  53          sbit dula=P2^6;
  54          sbit wela=P2^7;
  55          sbit beep=P2^3;
C51 COMPILER V8.08   MIMASUO                                                               08/18/2015 22:08:02 PAGE 2   

  56          
  57          unsigned char code table[]=
  58          {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,
  59          0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71,0x00,0x40};
  60          
  61          void delay(unsigned char i)
  62          {
  63   1              uchar j,k;
  64   1        for(j=i;j>0;j--)
  65   1          for(k=125;k>0;k--);
  66   1      }
  67          
  68          void display(uchar a,uchar b,uchar c,uchar d,uchar e,uchar f)
  69          {
  70   1         dula=0;
  71   1         P0=table[a];
  72   1         dula=1;
  73   1         dula=0;
  74   1         
  75   1         wela=0;
  76   1         P0=0xfe;
  77   1         wela=1;
  78   1         wela=0;
  79   1         delay(5);
  80   1         
  81   1         P0=table[b];
  82   1         dula=1;
  83   1         dula=0;
  84   1         
  85   1         P0=0xfd;
  86   1         wela=1;
  87   1         wela=0;
  88   1         delay(5);
  89   1      
  90   1         P0=table[c];
  91   1         dula=1;
  92   1         dula=0;
  93   1         
  94   1         P0=0xfb;
  95   1         wela=1;
  96   1         wela=0;
  97   1         delay(5);
  98   1         
  99   1         P0=table[d];
 100   1         dula=1;
 101   1         dula=0;
 102   1         
 103   1         P0=0xf7;
 104   1         wela=1;
 105   1         wela=0;
 106   1         delay(5);
 107   1         
 108   1         P0=table[e];
 109   1         dula=1;
 110   1         dula=0;
 111   1         
 112   1         P0=0xef;
 113   1         wela=1;
 114   1         wela=0;
 115   1         delay(5);
 116   1         
 117   1         P0=table[f];
C51 COMPILER V8.08   MIMASUO                                                               08/18/2015 22:08:02 PAGE 3   

 118   1         dula=1;
 119   1         dula=0;
 120   1         
 121   1         P0=0xdf;
 122   1         wela=1;
 123   1         wela=0;
 124   1         delay(5);
 125   1      }
 126          
 127          
 128          void keyscan()
 129          {
 130   1        {     
 131   2          P3=0xfe;
 132   2          temp=P3;
 133   2          temp=temp&0xf0;
 134   2          if(temp!=0xf0)
 135   2          {
 136   3            delay(10);
 137   3            if(temp!=0xf0)
 138   3            { 
 139   4              temp=P3;
 140   4              switch(temp)
 141   4              {
 142   5                case 0xee:
 143   5                     key=0;
 144   5                                 wei++;
 145   5                     break;
 146   5      
 147   5                case 0xde:
 148   5                     key=1;
 149   5                                 wei++;
 150   5                     break;
 151   5      
 152   5                case 0xbe:
 153   5                     key=2;
 154   5                                 wei++;
 155   5                     break;
 156   5      
 157   5                case 0x7e:
 158   5                     key=3;
 159   5                                 wei++;
 160   5                     break;
 161   5               }
 162   4               while(temp!=0xf0) 
 163   4              {
 164   5                 temp=P3;
 165   5                 temp=temp&0xf0;
 166   5                 beep=0;
 167   5               }
 168   4               beep=1;
 169   4            }
 170   3          }
 171   2          P3=0xfd;
 172   2          temp=P3;
 173   2          temp=temp&0xf0;
 174   2          if(temp!=0xf0)
 175   2          {
 176   3            delay(10);
 177   3            if(temp!=0xf0)
 178   3            {
 179   4              temp=P3;
C51 COMPILER V8.08   MIMASUO                                                               08/18/2015 22:08:02 PAGE 4   

 180   4              switch(temp)
 181   4              {
 182   5                case 0xed:
 183   5                     key=4;
 184   5                                 wei++;
 185   5                     break;
 186   5      
 187   5                case 0xdd:
 188   5                     key=5;
 189   5                                 wei++;
 190   5                     break;
 191   5      
 192   5                case 0xbd:
 193   5                     key=6;
 194   5                                 wei++;
 195   5                     break;
 196   5      
 197   5                case 0x7d:
 198   5                     key=7;
 199   5                                 wei++;
 200   5                     break;
 201   5               }
 202   4               while(temp!=0xf0)
 203   4               {
 204   5                 temp=P3;
 205   5                 temp=temp&0xf0;
 206   5                 beep=0;
 207   5               }
 208   4               beep=1;
 209   4            }
 210   3            }
 211   2          P3=0xfb;
 212   2          temp=P3;
 213   2          temp=temp&0xf0;
 214   2          if(temp!=0xf0)
 215   2          {
 216   3            delay(10);
 217   3            if(temp!=0xf0)
 218   3            {
 219   4              temp=P3;
 220   4              switch(temp)
 221   4              {
 222   5                case 0xeb:
 223   5                     key=8;
 224   5                                 wei++;
 225   5                     break;
 226   5      
 227   5                case 0xdb:
 228   5                     key=9;
 229   5                                 wei++;
 230   5                     break;
 231   5                                 
 232   5                case 0xbb:
 233   5                     genggai=1;
 234   5                                 wei=0;
 235   5                     break;
 236   5      
 237   5                case 0x7b:
 238   5                                 if(allow)
 239   5                     ok=1;
 240   5                     break;
 241   5               }
C51 COMPILER V8.08   MIMASUO                                                               08/18/2015 22:08:02 PAGE 5   

 242   4              while(temp!=0xf0)
 243   4               {
 244   5                 temp=P3;
 245   5                 temp=temp&0xf0;
 246   5                 beep=0;
 247   5               }
 248   4               beep=1;
 249   4            }
 250   3            }
 251   2                P3=0xf7;
 252   2          temp=P3;
 253   2          temp=temp&0xf0;
 254   2          if(temp!=0xf0)
 255   2          {
 256   3            delay(10);
 257   3            if(temp!=0xf0)
 258   3            {
 259   4              temp=P3;
 260   4              switch(temp)
 261   4              {
 262   5                case 0xe7:
 263   5                                 retry=1;
 264   5                     break;
 265   5      
 266   5                case 0xd7:
 267   5                                 close=1;
 268   5                     break;
 269   5               }
 270   4              while(temp!=0xf0)
 271   4               {
 272   5                 temp=P3;
 273   5                 temp=temp&0xf0;
 274   5                 beep=0;
 275   5               }
 276   4               beep=1;
 277   4            }
 278   3            }
 279   2      }
 280   1      }
 281          
 282          void shumima()          //对按键采集来的数据进行分配
 283          {
 284   1              if(!wanbi)
 285   1              {
 286   2              switch(wei)
 287   2              {
 288   3                      case 1:new1=key; 
 289   3                                  if(!allow)  a=17;
 290   3                                 else a=key;  break;
 291   3                      case 2:new2=key;
 292   3                                      if(a==17) b=17;
 293   3                                      else b=key;     break;
 294   3                      case 3:new3=key; 
 295   3                                      if(a==17) c=17;
 296   3                                      else c=key;     break;
 297   3                      case 4:new4=key;
 298   3                                      if(a==17) d=17;
 299   3                                      else d=key;     break;
 300   3                      case 5:new5=key; 
 301   3                                      if(a==17) e=17;
 302   3                                      else e=key;     break;
 303   3                      case 6:new6=key; 
C51 COMPILER V8.08   MIMASUO                                                               08/18/2015 22:08:02 PAGE 6   

 304   3                                      if(a==17) f=17;
 305   3                                      else f=key;
 306   3                                      wanbi=1;        break;
 307   3              }
 308   2              }
 309   1      }
 310          
 311          void yanzheng()   //验证密码是否正确
 312          {
 313   1              if(wanbi)        //只有当六位密码均输入完毕后方进行验证
 314   1              {
 315   2              if((new1==old1)&(new2==old2)&(new3==old3)&(new4==old4)&(new5==old5)&(new6==old6))
 316   2                      allow=1;        //当输入的密码正确，会得到allowe置一
 317   2              }
 318   1      }
 319          
 320          void main()
 321          {
 322   1              while(1)
 323   1              {
 324   2                      keyscan();
 325   2                      shumima();
 326   2                      yanzheng();
 327   2                      if(allow)        //验证完后，若allow为1，则开锁
 328   2                      {
 329   3                              P1=0x00;
 330   3                              if(!genggai)
 331   3                                      wanbi=0;
 332   3                      }
 333   2                      if(genggai)       //当S16更改密码键被按下，genggai会被置一
 334   2                      {
 335   3                              if(allow)        //若已经把锁打开，才有更改密码的权限
 336   3                              {
 337   4                                      while(!wanbi)   //当新的六位密码没有设定完，则一直在这里循环
 338   4                                      {
 339   5                                              keyscan();
 340   5                                              shumima();
 341   5                                              if(retry|close)  //而当探测到重试键S18或者关闭密码锁键S19被按下时，则跳出
 342   5                                              {       wanbi=1;
 343   6                                                      break;
 344   6                                              }
 345   5                                              display(a,b,c,d,e,f);
 346   5                                      }
 347   4                              }
 348   3                      }
 349   2                      if(ok)    //更改密码时，当所有六位新密码均被按下时，可以按下此键，结束密码更改
 350   2                      {                 //其他时间按下此键无效
 351   3                              ok=0; wei=0;
 352   3                              genggai=0;
 353   3                              old1=new1;old2=new2;old3=new3; //此时，旧的密码将被代替
 354   3                              old4=new4;old5=new5;old6=new6;
 355   3                              a=16;b=16;c=16;d=16;e=16;f=16;
 356   3                      }
 357   2                      if(retry)       //当重试按键S18被按下，retry会被置位
 358   2                      {
 359   3                      retry=0; wei=0;wanbi=0;
 360   3                      a=16;b=16;c=16;d=16;e=16;f=16;
 361   3                      new1=0;new2=0;new3=0;new4=0;new5=0;new6=0;              
 362   3                      }
 363   2                      if(close)  //当关闭密码锁按键被按下，close会被置位
 364   2                      {
 365   3                              close=0;genggai=0;//所有变量均被清零。
C51 COMPILER V8.08   MIMASUO                                                               08/18/2015 22:08:02 PAGE 7   

 366   3                              wei=0;  wanbi=0;
 367   3                              allow=0;
 368   3                              P1=0xff;
 369   3                              a=16;b=16;c=16;d=16;e=16;f=16;
 370   3                              new1=0;new2=0;new3=0;new4=0;new5=0;new6=0;
 371   3                      }
 372   2                      display(a,b,c,d,e,f); //实时显示
 373   2              }
 374   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    871    ----
   CONSTANT SIZE    =     18    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     21       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      6    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
