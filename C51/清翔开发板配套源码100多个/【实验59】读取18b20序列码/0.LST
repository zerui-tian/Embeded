C51 COMPILER V8.08   0                                                                     08/18/2015 11:20:29 PAGE 1   


C51 COMPILER V8.08, COMPILATION OF MODULE 0
OBJECT MODULE PLACED IN 0.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE 0.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*********************************************************************************
   2          * 【编写时间】： 2014年3月5日
   3          * 【作    者】： 清翔电子:03
   4          * 【版    本】： 1.0
   5          * 【网    站】： http://www.qxmcu.com/ 
   6          * 【淘宝店铺】： http://qxmcu.taobao.com/ 
   7          * 【实验平台】： QX-MCS51 单片机开发板
   8          * 【外部晶振】： 11.0592mhz     
   9          * 【主控芯片】： STC89C52
  10          * 【编译环境】： Keil μVisio3  
  11          * 【程序功能】：                                                                                    
  12          * 【使用说明】： 
  13          *  说明：免费开源，不提供源代码分析.
  14          **********************************************************************************/
  15          
  16          /*读取DS18B20的64位序列码并显示在1602液晶上，如果读取正确结果，则在
  17          液晶第一行显示DS18B20 OK，第二行显示序列码，如果读取失败，则在液晶上
  18          显示DS18B20  ERR0R PLEASE CHECK ，用户可通过更改18B20接口自己外接。 */
  19          #include <reg51.h>
  20          #include <intrins.h>
  21          
  22          #define uchar unsigned char
  23          #define uint  unsigned int
  24          
  25          sbit DQ = P2^2;  //定义DS18B20端口DQ  
  26          sbit BEEP=P2^3 ; //蜂鸣器驱动线
  27          
  28          bit  presence ;
  29          
  30          sbit LCD_RS = P3^5;             
  31          sbit LCD_RW = P3^6;
  32          sbit LCD_EN = P3^4;
  33          
  34          uchar code  cdis1[ ] = {"   DS18B20 OK   "};
  35          uchar code  cdis2[ ] = {"                "};
  36          uchar code  cdis3[ ] = {" DS18B20  ERR0R "};
  37          uchar code  cdis4[ ] = {"  PLEASE CHECK  "};
  38          
  39          unsigned char data  display[2] = {0x00,0x00};
  40                                              
  41          unsigned char data  RomCode[8] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
  42          
  43          unsigned char Temp;
  44          unsigned char  crc;
  45          
  46          void beep();
  47          
  48          #define delayNOP(); {_nop_();_nop_();_nop_();_nop_();};
  49          
  50          /*******************************************************************/
  51          void delay1(int ms)
  52          {
  53   1       unsigned char y;
  54   1        while(ms--)
  55   1       {
C51 COMPILER V8.08   0                                                                     08/18/2015 11:20:29 PAGE 2   

  56   2        for(y = 0; y<250; y++)
  57   2        {
  58   3         _nop_();
  59   3         _nop_();
  60   3         _nop_();
  61   3         _nop_();
  62   3        }
  63   2       }
  64   1      }
  65          
  66          
  67          /*******************************************************************/
  68          /*                                                                 */
  69          /*写指令数据到LCD                                                  */
  70          /*RS=L，RW=L，E=高脉冲，D0-D7=指令码。                             */
  71          /*                                                                 */
  72          /*******************************************************************/
  73          
  74          void lcd_wcmd(uchar cmd)
  75          
  76          {                          
  77   1       //  while(lcd_busy());
  78   1          LCD_RS = 0;
  79   1       //   LCD_RW = 0;
  80   1          LCD_EN = 0;
  81   1          _nop_();
  82   1          _nop_(); 
  83   1          P0 = cmd;
  84   1          delayNOP();
  85   1          LCD_EN = 1;
  86   1          delayNOP();
  87   1          LCD_EN = 0;  
  88   1              delay1(5);
  89   1      }
  90          
  91          /*******************************************************************/
  92          /*                                                                 */
  93          /*写显示数据到LCD                                                  */
  94          /*RS=H，RW=L，E=高脉冲，D0-D7=数据。                               */
  95          /*                                                                 */
  96          /*******************************************************************/
  97          
  98          void lcd_wdat(uchar dat)
  99          {                          
 100   1      //   while(lcd_busy());
 101   1          LCD_RS = 1;
 102   1      //    LCD_RW = 0;
 103   1          LCD_EN = 0;
 104   1          P0 = dat;
 105   1          delayNOP();
 106   1          LCD_EN = 1;
 107   1          delayNOP();
 108   1          LCD_EN = 0; 
 109   1              delay1(5);
 110   1      }
 111          
 112          /*******************************************************************/
 113          /*                                                                 */
 114          /*  LCD初始化设定                                                  */
 115          /*                                                                 */
 116          /*******************************************************************/
 117          
C51 COMPILER V8.08   0                                                                     08/18/2015 11:20:29 PAGE 3   

 118          void lcd_init()
 119          { 
 120   1           LCD_RW = 0;
 121   1          delay1(15);   
 122   1          lcd_wcmd(0x01);      //清除LCD的显示内容
 123   1                  
 124   1          lcd_wcmd(0x38);      //16*2显示，5*7点阵，8位数据
 125   1          delay1(5);
 126   1          lcd_wcmd(0x38);         
 127   1          delay1(5);
 128   1          lcd_wcmd(0x38);         
 129   1          delay1(5);
 130   1      
 131   1          lcd_wcmd(0x0c);      //显示开，关光标
 132   1          delay1(5);
 133   1          lcd_wcmd(0x06);      //移动光标
 134   1          delay1(5);
 135   1          lcd_wcmd(0x01);      //清除LCD的显示内容
 136   1          delay1(5);
 137   1      }
 138          
 139          /*******************************************************************/
 140          /*                                                                 */
 141          /*  设定显示位置                                                   */
 142          /*                                                                 */
 143          /*******************************************************************/
 144          
 145          void lcd_pos(uchar pos)
 146          {                          
 147   1        lcd_wcmd(pos | 0x80);  //数据指针=80+地址变量
 148   1      }
 149          
 150          /*******************************************************************/
 151          /*                                                                 */
 152          /*us级延时函数                                                     */
 153          /*                                                                 */
 154          /*******************************************************************/
 155          
 156          void Delay(unsigned int num)
 157          {
 158   1        while( --num );
 159   1      }
 160          
 161          /*******************************************************************/
 162          /*                                                                 */
 163          /*初始化ds1820                                                     */
 164          /*                                                                 */
 165          /*******************************************************************/
 166          Init_DS18B20(void)
 167          {  
 168   1           DQ = 1;      //DQ复位
 169   1           Delay(8);    //稍做延时
 170   1      
 171   1           DQ = 0;      //将DQ拉低
 172   1           Delay(90);   //精确延时 大于 480us
 173   1      
 174   1           DQ = 1;       //拉高总线
 175   1           Delay(8);
 176   1      
 177   1           presence = DQ;    //读取存在信号
 178   1           Delay(100);
 179   1           DQ = 1; 
C51 COMPILER V8.08   0                                                                     08/18/2015 11:20:29 PAGE 4   

 180   1           
 181   1           return(presence); //返回信号，0=presence,1= no presence
 182   1      }
 183          
 184          /*******************************************************************/
 185          /*                                                                 */
 186          /* 读一位（bit）                                                   */
 187          /*                                                                 */
 188          /*******************************************************************/
 189          uchar read_bit(void) 
 190          {
 191   1      unsigned char i;
 192   1      DQ = 0;                  //将DQ 拉低开始读时间隙
 193   1      DQ = 1;                         // then return high
 194   1      for (i=0; i<3; i++);    // 延时15μs
 195   1      return(DQ);                     // 返回 DQ 线上的电平值
 196   1      }
 197          
 198          /*******************************************************************/
 199          /*                                                                 */
 200          /* 读一个字节                                                      */
 201          /*                                                                 */
 202          /*******************************************************************/
 203           ReadOneChar(void)
 204          {
 205   1      unsigned char i = 0;
 206   1      unsigned char dat = 0;
 207   1      
 208   1      //for (i = 8; i > 0; i--)
 209   1      //  {
 210   1      //       read_bit();
 211   1      //    DQ = 0; // 给脉冲信号
 212   1      //     dat >>= 1;
 213   1      //    DQ = 1; // 给脉冲信号
 214   1      for (i=0;i<8;i++) 
 215   1      {                               // 读取字节，每次读取一个字节
 216   2      if(read_bit()) dat|=0x01<<i;    // 然后将其左移
 217   2      
 218   2      //    if(DQ)
 219   2      //     dat |= 0x80;
 220   2          Delay(4);
 221   2        }
 222   1      
 223   1          return (dat);
 224   1      }
 225          
 226          /*******************************************************************/
 227          /*                                                                 */
 228          /* 写一位                                                          */
 229          /*                                                                 */
 230          /*******************************************************************/
 231          void write_bit(char bitval) {
 232   1      DQ = 0;                                        // 将DQ 拉低开始写时间隙
 233   1      if(bitval==1) DQ =1;     // 如果写1，DQ 返回高电平
 234   1      Delay(5);                                     // 在时间隙内保持电平值，
 235   1      DQ = 1;                  // Delay函数每次循环延时16μs，因此delay(5) = 104μs
 236   1      }       
 237          
 238          /*******************************************************************/
 239          /*                                                                 */
 240          /* 写一个字节                                                      */
 241          /*                                                                 */
C51 COMPILER V8.08   0                                                                     08/18/2015 11:20:29 PAGE 5   

 242          /*******************************************************************/
 243           WriteOneChar(unsigned char dat)
 244          {
 245   1        unsigned char i = 0;
 246   1        unsigned char temp;
 247   1      //  for (i = 8; i > 0; i--)
 248   1      //  {
 249   1         for (i=0; i<8; i++)  // 写入字节, 每次写入一位 
 250   1         {
 251   2      //    DQ = 0;
 252   2      //    DQ = dat&0x01;
 253   2      //    Delay(5);
 254   2      
 255   2      //    DQ = 1;
 256   2         temp = dat>>i;               
 257   2         temp &= 0x01;                
 258   2         write_bit(temp);
 259   2      //    dat>>=1;
 260   2         
 261   2        }
 262   1        Delay(5);
 263   1      }
 264          
 265          /*******************************************************************/
 266          /*                                                                 */
 267          /* 读取64位序列码                                                  */
 268          /*                                                                 */
 269          /*******************************************************************/
 270           Read_RomCord(void)
 271          {
 272   1           unsigned char j;
 273   1           Init_DS18B20();
 274   1        
 275   1           WriteOneChar(0x33);  // 读序列码的操作
 276   1           for (j = 0; j < 8; j++)
 277   1               {
 278   2                RomCode[j] = ReadOneChar() ; 
 279   2               }
 280   1      }
 281          
 282          /*******************************************************************/
 283          /*                                                                 */
 284          /*DS18B20的CRC8校验程序                                            */
 285          /*                                                                 */
 286          /*******************************************************************/
 287          uchar CRC8() 
 288          { 
 289   1         uchar i,x; uchar crcbuff;
 290   1         
 291   1         crc=0;
 292   1         for(x = 0; x <8; x++)
 293   1         {
 294   2          crcbuff=RomCode[x];
 295   2          for(i = 0; i < 8; i++) 
 296   2           { 
 297   3            if(((crc ^ crcbuff)&0x01)==0) 
 298   3            crc >>= 1; 
 299   3             else { 
 300   4                    crc ^= 0x18;   //CRC=X8+X5+X4+1
 301   4                    crc >>= 1; 
 302   4                    crc |= 0x80; 
 303   4                  }         
C51 COMPILER V8.08   0                                                                     08/18/2015 11:20:29 PAGE 6   

 304   3            crcbuff >>= 1;       
 305   3               }
 306   2         }
 307   1           return crc;        
 308   1      }
 309          /*******************************************************************/
 310          /*                                                                 */
 311          /* 数据转换与显示                                                  */
 312          /*                                                                 */
 313          /*******************************************************************/
 314          
 315           Disp_RomCode()
 316          {
 317   1         uchar j;
 318   1         uchar H_num=0x40;       //LCD第二行初始位置
 319   1      
 320   1         for(j=0;j<8;j++)
 321   1         {
 322   2          Temp = RomCode[j];
 323   2      
 324   2          display[0]=((Temp&0xf0)>>4);
 325   2          if(display[0]>9)
 326   2           { display[0]=display[0]+0x37;}
 327   2          else{display[0]=display[0]+0x30;}
 328   2      
 329   2          lcd_pos(H_num);             
 330   2          lcd_wdat(display[0]);        //高位数显示 
 331   2      
 332   2          H_num++;
 333   2          display[1]=(Temp&0x0f);
 334   2          if(display[1]>9)
 335   2           {display[1]=display[1]+0x37;}
 336   2          else {display[1]=display[1]+0x30;}
 337   2      
 338   2          lcd_pos(H_num);             
 339   2          lcd_wdat(display[1]);        //低位数显示 
 340   2          H_num++;
 341   2         }
 342   1      }        
 343          
 344          /*******************************************************************/
 345          /*                                                                 */
 346          /* 蜂鸣器响一声                                                    */
 347          /*                                                                 */
 348          /*******************************************************************/
 349          void beep()
 350            {
 351   1          unsigned char y;
 352   1          for (y=0;y<100;y++)
 353   1          {
 354   2            Delay(60);
 355   2            BEEP=!BEEP;                //BEEP取反
 356   2          } 
 357   1          BEEP=1;                      //关闭蜂鸣器
 358   1              Delay(40000);
 359   1        }
 360          
 361          /*******************************************************************/
 362          /*                                                                 */
 363          /* DS18B20 OK 显示菜单                                             */
 364          /*                                                                 */
 365          /*******************************************************************/
C51 COMPILER V8.08   0                                                                     08/18/2015 11:20:29 PAGE 7   

 366          void  Ok_Menu ()
 367          { 
 368   1          uchar  m;
 369   1          lcd_init();                //初始化LCD 
 370   1                  
 371   1          lcd_pos(0);                //设置显示位置为第一行的第1个字符
 372   1           m = 0;
 373   1          while(cdis1[m] != '\0')
 374   1           {                         //显示字符
 375   2             lcd_wdat(cdis1[m]);
 376   2             m++;
 377   2           }
 378   1      
 379   1          lcd_pos(0x40);             //设置显示位置为第二行第1个字符
 380   1           m = 0;
 381   1          while(cdis2[m] != '\0')
 382   1           {
 383   2             lcd_wdat(cdis2[m]);      //显示字符
 384   2             m++;
 385   2           }
 386   1      }
 387          
 388          /*******************************************************************/
 389          /*                                                                 */
 390          /* DS18B20 ERROR 显示菜单                                          */
 391          /*                                                                 */
 392          /*******************************************************************/
 393          void  Error_Menu ()
 394          {
 395   1           uchar  m;
 396   1           lcd_init();                //初始化LCD 
 397   1              
 398   1               lcd_pos(0);                //设置显示位置为第一行的第1个字符
 399   1           m = 0;
 400   1           while(cdis3[m] != '\0')
 401   1           {                         //显示字符
 402   2             lcd_wdat(cdis3[m]);
 403   2             m++;
 404   2           }
 405   1      
 406   1           lcd_pos(0x40);             //设置显示位置为第二行第1个字符
 407   1           m = 0;
 408   1           while(cdis4[m] != '\0')
 409   1           {
 410   2             lcd_wdat(cdis4[m]);      //显示字符
 411   2             m++;
 412   2           }
 413   1      }
 414          
 415          /*******************************************************************/
 416          /*                                                                 */
 417          /* 主函数                                                          */
 418          /*                                                                 */
 419          /*******************************************************************/
 420          void main()
 421           {
 422   1           P0 = 0xff;
 423   1           P2 = 0xff;
 424   1      
 425   1         while(1)
 426   1        {
 427   2           Ok_Menu ();
C51 COMPILER V8.08   0                                                                     08/18/2015 11:20:29 PAGE 8   

 428   2           Read_RomCord();    //读取64位序列码
 429   2           CRC8();            //CRC效验
 430   2           if(crc==0)         //CRC效验正确
 431   2               {
 432   3                Disp_RomCode();       //显示64位序列码
 433   3                beep();
 434   3           }
 435   2           while(!presence)
 436   2               {
 437   3                Init_DS18B20();
 438   3                delay1(1000);
 439   3               }
 440   2      
 441   2           Error_Menu ();
 442   2              do
 443   2               {  
 444   3                 Init_DS18B20();
 445   3                 beep();
 446   3           }
 447   2              while(presence);
 448   2        }
 449   1      }
 450          
 451          /*******************************************************************/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    623    ----
   CONSTANT SIZE    =     68    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     12    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
