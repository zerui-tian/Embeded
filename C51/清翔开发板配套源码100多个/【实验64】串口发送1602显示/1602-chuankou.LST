C51 COMPILER V8.08   1602_CHUANKOU                                                         08/19/2015 12:19:44 PAGE 1   


C51 COMPILER V8.08, COMPILATION OF MODULE 1602_CHUANKOU
OBJECT MODULE PLACED IN 1602-chuankou.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE 1602-chuankou.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*********************************************************************************
   2          * 【编写时间】： 2014年3月5日
   3          * 【作    者】： 清翔电子:03
   4          * 【版    本】： 1.0
   5          * 【网    站】： http://www.qxmcu.com/ 
   6          * 【淘宝店铺】： http://qxmcu.taobao.com/ 
   7          * 【实验平台】： QX-MCS51 单片机开发板
   8          * 【外部晶振】： 11.0592mhz     
   9          * 【主控芯片】： STC89C52
  10          * 【编译环境】： Keil μVisio3  
  11          * 【程序功能】：                                                                                    
  12          * 【使用说明】： 液晶1脚接1602黑色排母的1脚  如果是无背光的液晶只有14个脚 排母右边空2个位   
  13                           请把液晶对比度电位器顺时针调制10点钟方向，请勿多调超出极限位置会损坏电位器！
  14          *  说明：免费开源，不提供源代码分析.
  15          **********************************************************************************/
  16           
  17          /************************************************************************
  18          * 描述：（用串口调试助手软件观察）                                      
  19          *   主机发送0123456789abcdef给单片机，单片机接收到数据后发送QX-MCU789abcdef给主机。     
  20          *   LCD1602上显示          0123456789abcdef 
  21          *   LCD1602显示接收数据的ASCII码。  波特率9600    发送和接收都要选择为文本格式                          
  22          *   注：当单片机收到数据只有凑够16个时才会一次在液晶上显示出来              
  23          ************************************************************************/
  24          
  25          #include <reg52.h>
  26          #include <intrins.h>
  27                  
  28          #define uchar  unsigned char 
  29          #define uint   unsigned int
  30          
  31          sbit LCD_RS = P3^5;
  32          sbit LCE_RW = P3^6;             
  33          sbit LCD_EN = P3^4;
  34          
  35          #define delayNOP(); {_nop_();_nop_();_nop_();_nop_();};
  36          
  37          
  38          uchar data  RXDdata[ ] = {0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
  39                                    0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20 };
  40          uchar temp,buf,m,count;
  41          
  42          bit   playflag=0;
  43          
  44          uchar code  cdis1[ ] = {" SERILA TRANFER "};
  45          uchar code  cdis2[ ] = {"                "};
  46          
  47          /**********************************************************
  48          
  49           延时子程序
  50          
  51          **********************************************************/
  52          void delay1(uint ms) 
  53          
  54          {
  55   1         uchar k;
C51 COMPILER V8.08   1602_CHUANKOU                                                         08/19/2015 12:19:44 PAGE 2   

  56   1         while(ms--)
  57   1         {
  58   2           for(k = 0; k < 120; k++);
  59   2         }
  60   1      }
  61          
  62          /*******************************************************************/
  63          /*                                                                 */
  64          /*写指令数据到LCD                                                  */
  65          /*RS=L，RW=L，E=高脉冲，D0-D7=指令码。                             */
  66          /*                                                                 */
  67          /*******************************************************************/
  68          void lcd_wcmd(uchar cmd)
  69          {                          
  70   1       //  while(lcd_busy());
  71   1          LCD_RS = 0;
  72   1        //  LCD_RW = 0;
  73   1          LCD_EN = 0;
  74   1          _nop_();
  75   1          _nop_(); 
  76   1          P0 = cmd;
  77   1          delayNOP();
  78   1          LCD_EN = 1;
  79   1          delayNOP();
  80   1          LCD_EN = 0;  
  81   1      }
  82          
  83          /*******************************************************************/
  84          /*                                                                 */
  85          /*写显示数据到LCD                                                  */
  86          /*RS=H，RW=L，E=高脉冲，D0-D7=数据。                               */
  87          /*                                                                 */
  88          /*******************************************************************/
  89          void lcd_wdat(uchar dat)
  90          {                          
  91   1      //   while(lcd_busy());
  92   1          LCD_RS = 1;
  93   1        //  LCD_RW = 0;
  94   1          LCD_EN = 0;
  95   1          P0 = dat;
  96   1          delayNOP();
  97   1          LCD_EN = 1;
  98   1          delayNOP();
  99   1          LCD_EN = 0; 
 100   1      }
 101          
 102          /*******************************************************************/
 103          /*                                                                 */
 104          /*  LCD初始化设定                                                  */
 105          /*                                                                 */
 106          /*******************************************************************/
 107          void lcd_init()
 108          { 
 109   1           LCE_RW = 0; 
 110   1          delay1(15);   
 111   1          lcd_wcmd(0x01);      //清除LCD的显示内容            
 112   1          lcd_wcmd(0x38);      //16*2显示，5*7点阵，8位数据
 113   1          delay1(5);
 114   1          lcd_wcmd(0x38);         
 115   1          delay1(5);
 116   1          lcd_wcmd(0x38);         
 117   1          delay1(5);
C51 COMPILER V8.08   1602_CHUANKOU                                                         08/19/2015 12:19:44 PAGE 3   

 118   1      
 119   1          lcd_wcmd(0x0c);      //开显示，显示光标，光标闪烁
 120   1          delay1(5);
 121   1      
 122   1          lcd_wcmd(0x01);      //清除LCD的显示内容
 123   1          delay1(5);
 124   1      }
 125          
 126          /*******************************************************************/
 127          /*                                                                 */
 128          /*  设定显示位置                                                   */
 129          /*                                                                 */
 130          /*******************************************************************/
 131          
 132          void lcd_pos(uchar pos)
 133          {                          
 134   1        lcd_wcmd(pos | 0x80);  //数据指针=80+地址变量
 135   1      }
 136          
 137          /*********************************************************
 138          
 139            发送数据函数
 140          
 141          *********************************************************/
 142          void senddata(uchar dat)
 143          {
 144   1           SBUF =dat;
 145   1           while(!TI);
 146   1           TI = 0;
 147   1      }
 148          
 149          /*********************************************************
 150          
 151            串行中断服务函数
 152          
 153          *********************************************************/
 154          void  serial() interrupt 4 
 155          {
 156   1         ES = 0;                //关闭串行中断
 157   1         RI = 0;                //清除串行接受标志位
 158   1         buf = SBUF;            //从串口缓冲区取得数据
 159   1           
 160   1         switch(buf)
 161   1         {
 162   2            case 0x31:  senddata('Q');break;  //接受到1，发送字符'Q'给计算机         
 163   2            case 0x32:  senddata('X');break;  //接受到2，发送字符'X'给计算机       
 164   2            case 0x33:  senddata('-');break;  //接受到3，发送字符'-'给计算机       
 165   2            case 0x34:  senddata('M');break;  //接受到4，发送字符'M'给计算机       
 166   2            case 0x35:  senddata('C');break;  //接受到5，发送字符'C'给计算机           
 167   2            case 0x36:  senddata('U');break;  //接受到5，发送字符'U'给计算机                  
 168   2            default:    senddata(buf);break;  //接受到其它数据，将其发送给计算机         
 169   2         }
 170   1      
 171   1         if(buf!=0x0D)
 172   1         {   
 173   2           if(buf!=0x0A)
 174   2           { 
 175   3             temp =buf;
 176   3             if(count<16)
 177   3             {         
 178   4               RXDdata[count]=temp;
 179   4               count++;
C51 COMPILER V8.08   1602_CHUANKOU                                                         08/19/2015 12:19:44 PAGE 4   

 180   4                       if(count==16)
 181   4                              playflag=1;
 182   4             }
 183   3           } 
 184   2         }
 185   1         ES = 1;    //允许串口中断
 186   1      }
 187          
 188          /*********************************************************
 189          
 190            数据显示函数
 191          
 192          *********************************************************/
 193          void  play()
 194          {
 195   1         if(playflag)
 196   1         { 
 197   2           lcd_pos(0x40);           //设置位置为第二行
 198   2           for(m=0;m<16;m++) 
 199   2           {
 200   3                      lcd_wdat(cdis2[m]);      //清LCD1602第二行
 201   3                      delay1(5);
 202   3               }
 203   2               lcd_pos(0x40);           //设置位置为第二行
 204   2           for(m=0;m<16;m++)
 205   2           {
 206   3          //   lcd_pos(0x40+m);       //设置显示位置为第二行
 207   3             lcd_wdat(RXDdata[m]);  //显示字符 
 208   3                 delay1(5);
 209   3           }
 210   2      
 211   2           playflag=0;              
 212   2           count=0x00;
 213   2      
 214   2           for(m=0;m<16;m++)      
 215   2           {
 216   3                      RXDdata[m]=0x20;         //清显存单元    
 217   3                      delay1(5);
 218   3               }
 219   2         }               
 220   1      }
 221          
 222          /*********************************************************
 223          
 224            主函数
 225          
 226          *********************************************************/
 227          void main(void) 
 228          {
 229   1          P0 = 0xff;
 230   1          P2 = 0xff;         
 231   1          
 232   1          SCON=0x50;           //设定串口工作方式
 233   1          PCON=0x00;           //波特率不倍增
 234   1                              
 235   1          TMOD=0x20;           //定时器1工作于8位自动重载模式, 用于产生波特率
 236   1          EA=1;
 237   1          ES = 1;              //允许串口中断
 238   1          TL1=0xfd;
 239   1          TH1=0xfd;             //波特率9600
 240   1          TR1=1;
 241   1      
C51 COMPILER V8.08   1602_CHUANKOU                                                         08/19/2015 12:19:44 PAGE 5   

 242   1          lcd_init();
 243   1          lcd_pos(0x00);        //设置显示位置为第一行
 244   1          for(m=0;m<16;m++) 
 245   1          {
 246   2                      lcd_wdat(cdis1[m]);   //显示字符
 247   2                      delay1(5);
 248   2              }
 249   1          lcd_pos(0x40);        //设置显示位置为第二行
 250   1          for(m=0;m<16;m++) 
 251   1          {
 252   2                      lcd_wdat(cdis2[m]);   //显示字符            
 253   2                      delay1(5);
 254   2              }
 255   1          while(1)        
 256   1          {
 257   2            play();       
 258   2          }
 259   1      }
 260          
 261          /*********************************************************/ 


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    421    ----
   CONSTANT SIZE    =     34    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     20    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
